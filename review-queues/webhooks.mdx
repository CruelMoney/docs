---
title: "Webhooks"
sidebarTitle: "Webhooks"
---

You can set up webhooks for common events and actions from the [moderation queue](/review-queues/overview). This is useful if you want to integrate the queue with your own systems. Webhooks are configured under [integrations in your dashboard](https://dash.moderationapi.com/moderation/integrations)<br></br>

The webhook payload will be sent as a `POST` request to the URL you specify. <br></br>

The webhooks require your server to respond with a 200 status code within 5 seconds, otherwise they will be retried. Webhooks are tried at most 5 times. <br></br>

## Webhook payload

<br></br>

<ResponseField name="id" type="string" required>
  The unique id of the event.
</ResponseField>
<ResponseField name="type" type="string" required>
  The type of the webhook. Can be `QUEUE_ITEM_NEW`, `QUEUE_ITEM_ACTION` or
  `QUEUE_ITEM_COMPLETED`.
</ResponseField>
<ResponseField name="timestamp" type="number" required>
  The timestamp of when the webhook was sent.
</ResponseField>
<ResponseField name="item" type="Item Object" required>
  The content item that triggered the webhook.
  <Expandable title="properties">
    <ResponseField name="id" type="string" required>
      The id of the content item.
    </ResponseField>
    <ResponseField name="flagged" type="boolean" required>
      Whether or not the content item has been flagged by your project
      configuration.
    </ResponseField>
    <ResponseField name="labels" type="array" required>
      An array of labels that the content item has been analyzed for - comes
      from your project configuration.
    </ResponseField>
    <ResponseField name="language" type="string" required>
      The ISO2 language code of the content item.
    </ResponseField>
    <ResponseField name="content" type="string" required>
      The original content of the content item.
    </ResponseField>
    <ResponseField name="timestamp" type="number" required>
      The timestamp of when the content item was submitted.
    </ResponseField>
    <ResponseField name="metadata" type="object">
      The metadata of the content item. Specified by you when sending the
      content for [moderation](/api-reference).
    </ResponseField>
    <ResponseField name="contextId" type="string">
      The context id of the content item. Specified by you when sending the
      content for [moderation](/api-reference).
    </ResponseField>
    <ResponseField name="authorId" type="string">
      The author id of the content item. Specified by you when sending the
      content for [moderation](/api-reference).
    </ResponseField>
  </Expandable>
</ResponseField>
<ResponseField name="queue" type="object">
  The queue that the content item is in.
  <Expandable title="properties">
    <ResponseField name="id" type="string" required>
      The id of the queue.
    </ResponseField>
    <ResponseField name="name" type="string" required>
      The name of the queue.
    </ResponseField>
  </Expandable>
</ResponseField>
<ResponseField name="action" type="object">
  The action that was taken on the content item if the type is
  `QUEUE_ITEM_ACTION`.
  <Expandable title="properties">
    <ResponseField name="id" type="string" required>
      The id of the action.
    </ResponseField>
    <ResponseField name="name" type="string" required>
      The name of the action.
    </ResponseField>
    <ResponseField name="value" type="string">
      The value of the action.
    </ResponseField>
  </Expandable>
</ResponseField>
<br></br>

```json Webhook payload example
{
  "id": "123",
  "type": "QUEUE_ITEM_ACTION",
  "timestamp": 1691496019049,
  "item": {
    "id": "644718a7fc78a41ec9f34a6d",
    "flagged": true,
    "labels": [
      {
        "label": "nsfw/UNSAFE",
        "score": 0.7266457980882517,
        "flagged": true,
        "manual": false
      },
      {
        "label": "nsfw/SENSITIVE",
        "score": 0.01,
        "flagged": false,
        "manual": false
      }
    ],
    "language": "en",
    "content": "Example content",
    "timestamp": 1691496019049,
    "metadata": {
      "key": "value"
    }
  },
  "queue": {
    "id": "123",
    "name": "My queue"
  },
  "action": {
    "id": "123",
    "name": "Remove content",
    "value": "spam"
  },
  "contextId": "demo-context",
  "authorId": "author-123"
}
```

## Webhook signing

You can verify that the webhook is coming from us by comparing the signature of the payload with the signature provided in the `modapi-signature` header. <br></br>

The signature is a `HMAC SHA256` hash of the payload using your webhook secret as the key. Find you webhook secret under [integrations in your dashboard](https://dash.moderationapi.com/moderation/integrations).

<CodeGroup>

```js Next.js SDK (app router)
import ModerationAPI from "@moderation-api/sdk";

// Option 1: Use environment variable MODAPI_SECRET_KEY
const moderationApi = new ModerationAPI();

// Option 2: Pass key explicitly
// const moderationApi = new ModerationAPI({ key: 'proj_...' });

export async function POST(request: Request) {
  try {
    const body = await request.text();
    const headersList = await headers();
    const webhookSignatureHeader = headersList.get("modapi-signature");

    if (!webhookSignatureHeader) {
      return NextResponse.json(
        { error: "No signature header" },
        { status: 400 }
      );
    }

    // Option 1: Use environment variable MODAPI_WEBHOOK_SECRET
    const payload = await moderationApi.webhooks.constructEvent(
      Buffer.from(body),
      webhookSignatureHeader
    );

    // Option 2: Pass secret explicitly (overrides environment variable)
    // const payload = await moderationApi.webhooks.constructEvent(
    //   Buffer.from(body),
    //   webhookSignatureHeader,
    //   'whsec_...'
    // );

    return NextResponse.json({ received: true });
  } catch (error) {
    console.error("Error processing webhook:", error);
    return NextResponse.json(
      { error: "Error processing webhook" },
      { status: 400 }
    );
  }
}

```

```js Next.js SDK (pages router)
import ModerationAPI from "@moderation-api/sdk";
import { buffer } from "micro";

// Use environment variable MODAPI_SECRET_KEY
const moderationApi = new ModerationAPI();

const handler = async (req, res) => {
  const webhookRawBody = await buffer(req);
  const webhookSignatureHeader = req.headers["modapi-signature"];

  // Option 1: Use environment variable MODAPI_WEBHOOK_SECRET
  const payload = await moderationApi.webhooks.constructEvent(
    webhookRawBody,
    webhookSignatureHeader
  );

  // Option 2: Pass secret explicitly (overrides environment variable)
  // const payload = await moderationApi.webhooks.constructEvent(
  //   webhookRawBody,
  //   webhookSignatureHeader,
  //   'whsec_...'
  // );

  res.json({ received: true });
};

// disable body parser so we can access raw body
export const config = {
  api: {
    bodyParser: false,
  },
};

export default handler;
```

```js Next.js webhook manual verification
import crypto from "crypto";
import { buffer } from "micro";

const handler = async (req, res) => {
  try {
    let rawBody = await buffer(req);
    rawBody = rawBody.toString("utf8");

    // The signature provided by Moderation API
    const signature = Buffer.from(
      req.headers["modapi-signature"] || "",
      "utf8"
    );

    if (signature.length > 0) {
      const digest = Buffer.from(
        crypto
          .createHmac("sha256", process.env.MODAPI_WEBHOOK_SECRET)
          .update(rawBody)
          .digest("hex"),
        "utf8"
      );

      // Compare the provided signature to the one we generated
      const isValid =
        signature.length == digest.length &&
        crypto.timingSafeEqual(signature, digest);

      if (!isValid) {
        throw new Error(
          `Request body digest (${digest}) did not match modapi-signature (${signature})`
        );
      }
    }

    const payload = JSON.parse(rawBody);

    console.log({ payload });

    res.json({
      ok: true,
    });
  } catch (error) {
    res.status(500).json({
      error,
      time: new Date(),
    });
  }
};

// disable body parser so we can access raw body
export const config = {
  api: {
    bodyParser: false,
  },
};

export default handler;
```

</CodeGroup>

### Preventing replay attacks

To prevent replay attacks, you can use the timestamp in the payload of the webhook to ensure that the webhook is not older than 5 minutes. <br></br>

## Troubleshooting

### Check events log

If webhooks aren't working as expected, first check the [events log](https://dash.moderationapi.com/moderation/events) in your dashboard to see detailed information about webhook delivery attempts and any failures.

### Allow Moderation API

You may find that some hosting providers and security services block webhook traffic. For example Cloudflare's Bot Fight mode will present a challenge instead of allowing the webhook.

<Tabs>
  <Tab title="Cloudflare">
    ### Common blocking scenarios
    - Bot Fight Mode / Super Bot Fight Mode is enabled 
    - WAF Managed Rules active
    - Custom security rules

    ### Choose your solution based on your plan

    <Tabs>
      <Tab title="Super Bot Fight Mode (Pro+)">
        **✅ Use Security Rules (Recommended)**

        1. Go to your Cloudflare dashboard
        2. Select your domain
        3. Navigate to **Security → Security rules**
        4. Create a custom rule:
           - **Name**: "Moderation API Webhooks"
           - **Field**: User Agent
           - **Operator**: starts with
           - **Value**: `ModAPI/`
           - **Action**: Skip `All Super Bot Fight Mode Rules` and other rules that might interfere.
        5. Make sure to place this rule before other rules
        6. Deploy the rule

      </Tab>

      <Tab title="Bot Fight Mode (Free)">
        **❌ Security Rules won't work**

        Bot Fight Mode cannot be bypassed using Skip actions in WAF custom rules or Page Rules. Skip, Bypass, and Allow actions only apply to Ruleset Engine rules.

        **✅ Solutions:**
        - **Option 1**: Upgrade to a Pro plan to use Super Bot Fight Mode (which can be bypassed)
        - **Option 2**: Create a rule to allow Moderation API's IP address - see [Cloudflare's guide here](https://developers.cloudflare.com/waf/tools/ip-access-rules/create/), and reach out to support at [support@moderationapi.com](mailto:support@moderationapi.com) to get the IP address that is used for your Moderation API account
      </Tab>
    </Tabs>

  </Tab>
  
  <Tab title="Other Providers">
    **Common providers with security blocking:**
    - SiteDistrict
    - DigitalOcean App Platform  
    - Vercel
    - Netlify
    - AWS CloudFront
    - Azure Front Door

    **General configuration steps:**
    1. Access your provider's security/firewall settings
    2. Look for "allow rules", "exceptions", or "bypass rules"
    3. Add a User-Agent rule for `ModAPI/` (preferred)
    4. Or contact support to get IP addresses allowlisted for your account
    5. Save and deploy the configuration

    **Where to find settings:**
    - **Vercel**: Project settings → Security
    - **Netlify**: Site settings → Build & deploy → Post processing
    - **DigitalOcean**: App settings → Security section
    - **AWS CloudFront**: WAF & Shield → Web ACLs
    - **Azure Front Door**: Rules engine or WAF policies

    <Warning>
      Each provider uses different terminology. Look for "firewall rules", "security exceptions", or "allow rules" in your provider's documentation.
    </Warning>

  </Tab>
</Tabs>

### Still having issues?

**Troubleshooting steps:**

1. Check your hosting provider's security logs for blocked `ModAPI/` requests
2. Verify your webhook endpoint returns a 200 status code within 5 seconds
3. Test with a simple endpoint to isolate the issue
4. Ensure firewall rules don't conflict with allow rules

**Get help:**
Contact our support team at [support@moderationapi.com](mailto:support@moderationapi.com) for assistance with configuration or to allowlist our IP addresses for your specific account.
